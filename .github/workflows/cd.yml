name: Continuous Deployment

on:
  workflow_run:
    workflows: ["Continuous Integration"]
    branches: [main]
    types:
      - completed
  # Allow manual triggers
  workflow_dispatch:
    inputs:
      environment:
        description: 'Environment to deploy to'
        required: true
        default: 'staging'
        type: choice
        options:
          - staging
          - production
      version:
        description: 'Version to deploy (leave empty for latest)'
        required: false
        type: string

env:
  REGISTRY: ghcr.io
  IMAGE_NAME: ${{ github.repository }}/titanic-prediction
  KUBE_CONFIG_DATA: ${{ secrets.KUBE_CONFIG_DATA }}

jobs:
  prepare:
    name: Prepare Deployment
    runs-on: ubuntu-latest
    if: ${{ github.event.workflow_run.conclusion == 'success' || github.event_name == 'workflow_dispatch' }}
    outputs:
      version: ${{ steps.set-version.outputs.version }}
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v3
      
      - name: Set version
        id: set-version
        run: |
          if [[ "${{ github.event_name }}" == "workflow_dispatch" && "${{ github.event.inputs.version }}" != "" ]]; then
            echo "version=${{ github.event.inputs.version }}" >> $GITHUB_OUTPUT
          else
            echo "version=$(date +'%Y%m%d')-$(git rev-parse --short HEAD)" >> $GITHUB_OUTPUT
          fi
          echo "Version set to: $(cat $GITHUB_OUTPUT | grep version | cut -d= -f2)"

  deploy-staging:
    name: Deploy to Staging
    runs-on: ubuntu-latest
    needs: prepare
    environment: staging
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v3
      
      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v2
      
      - name: Log in to GitHub Container Registry
        uses: docker/login-action@v2
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}
      
      - name: Build and push Docker image
        uses: docker/build-push-action@v4
        with:
          context: .
          push: true
          tags: |
            ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${{ needs.prepare.outputs.version }}
            ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:staging-latest
          cache-from: type=gha
          cache-to: type=gha,mode=max
      
      - name: Set up kubectl
        uses: azure/k8s-set-context@v1
        with:
          kubeconfig: ${{ secrets.STAGING_KUBECONFIG }}
      
      - name: Deploy to Kubernetes
        run: |
          # Update image tag in deployment file
          sed -i "s|image:.*|image: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${{ needs.prepare.outputs.version }}|g" kubernetes/deployment.yaml
          
          # Apply ConfigMap and Secrets first
          kubectl apply -f kubernetes/configmap.yaml -n staging
          kubectl apply -f kubernetes/secrets.yaml -n staging
          
          # Apply other Kubernetes resources
          kubectl apply -f kubernetes/deployment.yaml -n staging
          kubectl apply -f kubernetes/service.yaml -n staging
          kubectl apply -f kubernetes/hpa.yaml -n staging
          kubectl apply -f kubernetes/ingress.yaml -n staging
          
          # Wait for deployment to be available
          kubectl rollout status deployment/titanic-prediction -n staging --timeout=300s
      
      - name: Perform health check
        run: |
          # Wait for service to be ready
          echo "Waiting for service to be available..."
          sleep 30
          
          # Get service URL
          STAGING_URL=$(kubectl get ingress titanic-prediction -n staging -o jsonpath='{.status.loadBalancer.ingress[0].ip}')
          
          # Check health endpoint
          HEALTH_STATUS=$(curl -s -o /dev/null -w "%{http_code}" http://$STAGING_URL/health)
          if [ "$HEALTH_STATUS" != "200" ]; then
            echo "Health check failed with status: $HEALTH_STATUS"
            exit 1
          fi
          
          echo "Health check passed"
      
      - name: Run automated tests against staging
        run: |
          pip install pytest requests
          # Run integration tests against staging environment
          python -m pytest tests/integration -v
      
      - name: Mark deployment as successful
        if: success()
        run: |
          echo "Staging deployment successful - ${{ needs.prepare.outputs.version }}"
          # Update deployment tracker or send notification
          curl -X POST -H "Content-Type: application/json" \
            -d '{"environment": "staging", "version": "${{ needs.prepare.outputs.version }}", "status": "success"}' \
            ${{ secrets.DEPLOYMENT_TRACKER_URL }} || true

      - name: Rollback on failure
        if: failure()
        run: |
          echo "Deployment failed, rolling back..."
          # Get the previous deployed version
          PREV_VERSION=$(kubectl get deployment titanic-prediction -n staging -o jsonpath='{.metadata.annotations.kubernetes\.io/previous-version}')
          
          if [ -n "$PREV_VERSION" ]; then
            # Rollback to previous version
            kubectl rollout undo deployment/titanic-prediction -n staging
            echo "Rolled back to previous version: $PREV_VERSION"
          else
            echo "No previous version found, unable to rollback automatically"
          fi

  promote-to-production:
    name: Promote to Production
    needs: [prepare, deploy-staging]
    runs-on: ubuntu-latest
    environment:
      name: production
      url: https://titanic-prediction.example.com
    # Requires manual approval via environment protection rules
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v3
      
      - name: Set up kubectl
        uses: azure/k8s-set-context@v1
        with:
          kubeconfig: ${{ secrets.PRODUCTION_KUBECONFIG }}
      
      - name: Promote Docker image
        uses: docker/login-action@v2
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}
      
      - name: Tag image for production
        run: |
          # Pull the staging image
          docker pull ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${{ needs.prepare.outputs.version }}
          
          # Tag it for production
          docker tag ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${{ needs.prepare.outputs.version }} \
            ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:production-latest
          
          # Push the production tag
          docker push ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:production-latest
      
      - name: Deploy to production
        run: |
          # Update image tag in deployment file
          sed -i "s|image:.*|image: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${{ needs.prepare.outputs.version }}|g" kubernetes/deployment.yaml
          
          # Store current deployment info for potential rollback
          CURRENT_VERSION=$(kubectl get deployment titanic-prediction -n production -o jsonpath='{.spec.template.spec.containers[0].image}' || echo "none")
          kubectl annotate deployment titanic-prediction -n production kubernetes.io/previous-version=$CURRENT_VERSION --overwrite || true
          
          # Apply ConfigMap and Secrets first
          kubectl apply -f kubernetes/configmap.yaml -n production
          kubectl apply -f kubernetes/secrets.yaml -n production
          
          # Apply other Kubernetes resources
          kubectl apply -f kubernetes/deployment.yaml -n production
          kubectl apply -f kubernetes/service.yaml -n production
          kubectl apply -f kubernetes/hpa.yaml -n production
          kubectl apply -f kubernetes/ingress.yaml -n production
          
          # Canary deployment - start with 20% of traffic
          kubectl scale deployment titanic-prediction -n production --replicas=5
          kubectl scale deployment titanic-prediction-canary -n production --replicas=1
          
          # Wait for deployment to be available
          kubectl rollout status deployment/titanic-prediction -n production --timeout=300s
      
      - name: Perform production health check
        run: |
          # Wait for service to be ready
          echo "Waiting for service to be available..."
          sleep 60
          
          # Get service URL
          PROD_URL=$(kubectl get ingress titanic-prediction -n production -o jsonpath='{.status.loadBalancer.ingress[0].ip}')
          
          # Check health endpoint
          HEALTH_STATUS=$(curl -s -o /dev/null -w "%{http_code}" https://$PROD_URL/health)
          
          # Check prediction endpoint
          PRED_STATUS=$(curl -s -o /dev/null -w "%{http_code}" -X POST -H "Content-Type: application/json" \
            -d '{"passenger_id": 1, "pclass": 3, "name": "Braund, Mr. Owen Harris", "sex": "male", "age": 22.0, "sibsp": 1, "parch": 0, "ticket": "A/5 21171", "fare": 7.25, "cabin": "", "embarked": "S"}' \
            https://$PROD_URL/api/v1/predict)
          
          if [ "$HEALTH_STATUS" != "200" ] || [ "$PRED_STATUS" != "200" ]; then
            echo "Health check failed - Health: $HEALTH_STATUS, Prediction: $PRED_STATUS"
            exit 1
          fi
          
          echo "Production health check passed"
      
      - name: Complete canary deployment
        if: success()
        run: |
          # If health checks pass, complete the canary deployment
          kubectl scale deployment titanic-prediction-canary -n production --replicas=0
          echo "Canary deployment completed successfully"
      
      - name: Rollback on failure
        if: failure()
        run: |
          echo "Production deployment failed, rolling back..."
          # Rollback to previous version
          kubectl rollout undo deployment/titanic-prediction -n production
          
          # Scale down canary deployment
          kubectl scale deployment titanic-prediction-canary -n production --replicas=0
          
          echo "Rolled back to previous version"
          
          # Send alert notification
          curl -X POST -H "Content-Type: application/json" \
            -d '{"environment": "production", "version": "${{ needs.prepare.outputs.version }}", "status": "rolled_back"}' \
            ${{ secrets.ALERT_WEBHOOK_URL }} || true
      
      - name: Send deployment notification
        if: always()
        run: |
          STATUS="${{ job.status }}"
          MESSAGE="Production deployment of titanic-prediction ${{ needs.prepare.outputs.version }} $STATUS"
          
          curl -X POST -H "Content-Type: application/json" \
            -d "{\"text\": \"$MESSAGE\"}" \
            ${{ secrets.SLACK_WEBHOOK_URL }} || true

